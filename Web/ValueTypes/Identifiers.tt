
<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
using System;
using System.ComponentModel;
using Saithe;

namespace SomeBasicEFApp.Web
{

<#
var types = new []{
    new {Name="CustomerId", Prefix="C-"}, 
    new {Name="OrderId", Prefix="O-"},
    new {Name= "ProductId", Prefix="P-"}};
foreach (var typeT in types){
var type =typeT.Name;
var prefix = typeT.Prefix;
#>
    [TypeConverter(typeof(ParseTypeConverter<<#= type #>>))]
    public struct <#= type #> : IEquatable<<#= type #>>, IId
    {
        public int Value { get; }

        public <#= type #>(int value)=>Value = value;

        public bool Equals(<#= type #> other) => Equals(Value, other.Value);

        public override bool Equals(object obj) => obj is <#= type #> id && Equals(id);
        public override int GetHashCode() => Value.GetHashCode();
        public override string ToString() => $"<#= prefix #>{Value}";

        public static <#= type #> Parse(string value)
        {
            if (string.IsNullOrEmpty(value))
                throw new ArgumentException("Missing value");
            if (!value.StartsWith("<#= prefix #>", StringComparison.InvariantCultureIgnoreCase))
                throw new FormatException($"Expected '{value}' to start with prefix '<#= prefix #>'");
            if (Int32.TryParse(value.Substring("<#= prefix #>".Length), out var result))
                return new <#= type #>(result);
            throw new FormatException($"Expected '{value}' to match '<#= prefix #>-\\d+'");
        }
        public static bool operator ==(<#= type #> a, <#= type #> b) => a.Equals(b);
        public static bool operator !=(<#= type #> a, <#= type #> b) => !a.Equals(b);
    }
<#
}
#>
}
